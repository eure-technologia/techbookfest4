= Redux on Android

== Reduxとは

=== Reduxが登場した背景
Androidアプリに求められる要件は年々複雑化してきており、それに伴って扱う状態も増えてきています。具体的には、UIに表示される画像やテキストデータ、ユーザーが入力したデータ、UI構築に必要な内部データなどが代表的なものです。さらにそれらのデータはサーバーから取得したものであったり、ローカルでキャッシュしたものであったりすることがより開発を難しくしています。シンプルなアプリであれば状態管理はそれほど問題になることはないですが、大規模なアプリになればなるほど状態管理はクリティカルな問題となることが多いです。

Reduxはこういった状態管理にまつわる問題を解消するために登場しました。本来はReactとセットでWebフロント開発で使われることが多いですが、Redux自体は非常にシンプルな考え方なので、Webフロント以外のプラットフォームにも容易に移植することができます。

=== Reduxの概要

Reduxを一言で表現すると、アプリケーションの状態管理に特化したフレームワークです。Fluxがベースになっており、アプリケーションにおけるデータの流れを1方向に制限することで状態管理にまつわる問題を解決する、というアプローチを採用しています。

TODO: 図を載せる

Reduxは次の3原則を中心に設計されており、これらを実現するための最小構成なフレームワークとして実装されています。

==== Single source of truth
Reduxではアプリの状態は1つのStoreと呼ばれる領域で管理されます。状態が1箇所で統括的に管理されることで見通しが良くなり、デバッグや状態のバリデーションなどもやりやすくなります。また、アプリの要件にも依存しますが、UNDO/REDOなども状態のスナップショットを保存することで容易に実装できます。

==== State is read-only
ReduxにおけるState（＝状態）は読み取り専用で定義されており、Stateの中身を変更することはできません。Stateを変更したい場合はStoreに対してActionをDispatchする必要があります。この制約があることにより、Stateの変更箇所が限定されることになるので、コードの見通しが良くなります。

==== Changes are made with pure functions
ReduxではStoreにDispatchされたActionをもとにStateを変更しますが、その変更処理はStore自体ではなく、Reducerが担当することになります。Reducerは現在のStateとActionを受け取り、そこから新しいStateを返す関数として実装すべし、という制約があります。この制約があることで、Reducerは同じStateとActionを与えて呼び出すと、必ず同じStateを返すため、テストが非常に書きやすくなる、というメリットがあります。

=== Fluxとの違い
ReduxはFluxがベースになっており、基本的な概念は同じですが、以下のような違いがあります。

* FluxではStoreの個数に制限はないが、ReduxではStoreが1個しかない

* Fluxでは状態変更を誰が行うのかは定められていないが、ReduxではReducerが担当する

基本的にはFluxでは曖昧に表現されていた箇所に制約を設けたものがReduxであり、根本にある考え方は同じです。

== Androidにおける状態管理の難しさ

本節では、Androidアプリにおける状態管理でどのような難しさが存在するのかを説明していきます。

=== 複数のデータソースを扱う必要性
Androidに限った話ではありませんが、昨今のフロントエンド開発では当たり前のようにデータソースが複数存在している場合が多いです。具体的には、API経由でやり取りするサーバー、SQLiteなどを使ったローカルDB、SharedPreferencesを使ったKey-Valueストア、メモリやディスクなどを使ったキャッシュなどなど、代表的なものでもこれだけのデータソースがあります。

データソースにはそれぞれ特徴があり、適したデータ形式やアクセス方法などがそれぞれ異なっています。

TODO: 図を載せる

このように、複数のデータソースの特徴を意識しながらコードを書いていくのはかなり大変な作業です。

=== 状態に種類があること（永続的な状態、一時的な状態）
Reduxは状態管理にまつわる問題を解決するために登場したものですが、状態と一口に言っても、実は色々な種類の状態があります。

==== 永続的な状態
サーバーやローカルDBに保存され、サービス内においては永続化されているものを指しています。

==== 一時的な状態
ユーザーが入力している最中のテキストや、メモリにキャッシュされた値などを指しています。

これらの状態は一貫性のある設計を採用していない限りは、コード内の色々な箇所で管理され、コードの見通しが悪くなる要因となります。

=== 非同期処理の扱い、非同期処理後の状態変更
Androidでは時間のかかる処理はメインスレッド以外のスレッドで実行します。Androidで非同期処理を実行する場合は、AsyncTask、Loader、Serviceなどを使うことになりますが、これらはそれぞれ実装方法が大きくことなっており、状態管理が複雑化する要因になってしまいます。また、マルチスレッドプログラミング自体がそもそも難易度の高い手法であることも状態管理を難しくする要因になります。

== 状態管理の難しさにReduxで対抗する
本節では、Androidアプリ開発における状態管理の難しさに対して、Reduxで対抗するアプローチを説明していきます。

=== 状態管理がどのように変わるか
本項では、Reduxを採用した場合にアプリの状態管理がどのように変わるのかを説明していきます。

==== データソースの違いを隠蔽できる
Reduxにおいてはアプリの状態は全てStoreで管理され、ViewはStoreから渡された状態を使って画面を構築することになります。Storeが保持する状態が変更された場合はStoreから通知を受け取って画面を再描画します。これにより、Viewが具体的なデータソースを知ることがありません。

==== 状態の種類によらずStoreで管理することでシンプルになる
アプリの状態には「永続的な状態」と「一時的な状態」の2つが存在します。いずれの状態もStoreで一括管理することでシンプルに実装することが可能です。

==== 非同期処理と状態管理を分離することでテスタビリティを担保できる
Reduxでは非同期処理はActionCreator、状態管理はStoreという形で明確に責務が分離されています。ActionCreatorは非同期処理の実行に必要なデータを受け取り、非同期処理を実行してActionを返却するまでが責務です。StoreはDispatcher経由でActionを受け取り、状態を更新するまでが責務です。Storeの中でActionをもとに状態を更新するのはReducerが行います。

ActionCreatorのテストは、引数と返戻値のペアが正しいことをチェックします。Storeのテストは、ActionとStoreの状態のペアが正しいことをチェックします。ReducerはActionとStateを受け取り、Stateを返す関数として実装されるのでテストを書くのは簡単です。

=== 不揮発性の状態、揮発性の状態を区別して扱う
本項では、Storeが管理する状態をStore内部で2つ分解するアプローを説明していきます。

==== 不揮発性の状態
不揮発性の状態とは、ユーザーデータや画面に表示されているテキストデータなどの値として表現される状態を指しています。

==== 揮発性の状態
揮発性の状態とは、画面遷移や通知といったイベントとして表現される状態を指しています。

これらの状態を区別している理由は大きく次の2つです。

1. 不揮発性の状態は値が保持されていることに意味があり、最新の値をキャッシュしておく必要があるから
2. 揮発性の状態はイベントを保持する必要はなく、あくまでイベントが流れたことに意味があるから

=== 非同期処理の扱い
本項では、Reduxにおける非同期処理の実装方針を紹介していきます。

==== 非同期処理をActionCreatorとして切り出す
Reduxでは非同期処理をActionCreatorとして切り出します。ActionCreatorは非同期処理の実行に必要なデータを受け取り、非同期処理を実行します。その結果はActionとして表現され、Dispatcher経由でStoreに渡されます。重要なのは非同期処理とその結果が明確に分離されている点で、これによりテスタビリティを高めることができます。

==== 非同期処理の結果をActionとして表現し、Reducerで状態変更を行う
ActionCreatorが実行した非同期処理の結果はActionとして表現されます。ActionはDispatcherを経由してStoreに渡されて状態変更が行われますが、この状態変更はReducerが実行します。ReducerはActionとStateを受け取り、そこから新しいStateを返します。Reducerは単純な関数として実装されるため、非常に簡単にテスト可能です。
