# swift-nioで始めるEvent Driven Network Application

## 目次
* 導入
* try! Swift 2018とSwiftNIO
* 同期/非同期とブロッキング/ノンブロッキング
	* ブロッキング/同期IO
	* マルチスレッド
	* ノンブロッキングIO
	* SwiftNIOはノンブロッキングIO
* Hello, SwiftNIO!
	* Dockerのインストール
	* Dockerを使ってサンプルを立ち上げる
* swift-nioで作るチャットアプリケーション
	* TBD

## 導入
はじめましてこんにちは。株式会社エウレカでiOSエンジニアとして主にUI/UX周りの開発を担当しています、@satoshin21です。
最近一眼カメラを入手し、夜な夜な風景を撮っています。大きなカンファレンスのカメラマンとしてデビューする事を夢見てカメラの勉強中です。

### try! Swift 2018とSwiftNIO
try! Swift 2018にて、最も盛り上がったセッションの一つとして、AppleのServer Infrastructure Teamの一人であるNorman Maurerによる「Event driven networking for Swift」があげられるかと思います。
このセッションの最後でSwiftNIOがその日のうちに公開され、大きな歓声が巻き上がりました。
SwiftNIOは、高性能なネットワークアプリケーションを構築する際に構築する際に使われる低レベルなツールとして紹介されています。いわゆるWebアプリケーションを開発する際に広く使われているVaporやKituraなどの高レベルなフレームワークと違い、我々開発者は直接このSwiftNIOを直接使う機会というのはそれほどないのかもしれません。
- [ ] しかし、Vaporでも早速SwiftNIOを採用し、今後WebアプリケーションをSwiftで書く時には、SwiftNIOなどの低レベル部分についての概念については理解しておくことで、より効率的な開発が可能になるかと思います！(ちなみに、VaporはSwiftNIOを採用することで、およそ15000行のコード削減に成功したようです。)
- [ ]
果たして、このSwiftNIOとは一体何者なのでしょうか？

### 同期・非同期 ブロッキング・ノンブロッキング
SwiftNIOのREADMEには、SwiftNIOの概念について以下のように記載されています。

```
It particularly targets those use-cases where using a "thread-per-connection" model of concurrency is inefficient or untenable.

...

To achieve its goals SwiftNIO extensively uses "non-blocking I/O": hence the name!
```
SwiftNIOは、各コネクションにつき一つのスレッドを使用する設計では非効率、及び実行不可能なケースとなる事を懸念し、それらに対応する為にノンブロッキングIOを採用しています。
ノンブロッキングIOモデルについて、SwiftNIO上では **アプリケーションがネットワークとの間でデータ送受信を待機しない、いわゆるブロッキングIOモデルとは異なる** と紹介されています。

同期処理は、基本的にノンブロッキングと同義です。
同期処理ですと、処理が完了しない限り次の処理が実行できません。これがいわゆるブロッキングです。通信に時間がかかったり、単純にやり取りするデータ量が増大すると、その分IO処理にコストが掛かり、場合によって非常に非効率となります。

それを解消するのが非同期IOです。
非同期IOは、IO処理を呼び出し元のスレッド・プロセスとは独立して行うことで、呼び出し元はIO処理に待たされる事なく、別の処理を行うことができます。
非同期IOを実現する手段として、マルチスレッドとノンブロッキングがあります。
マルチスレッドは、いわゆるiOS開発でもよく使われているかと思います。各処理毎にスレッドを生成し、呼び出し元と平行に処理を行うことができます。しかし、各スレッドでも同様にIOの待機状態は発生します。仮に1つのスレッドで特定のIOの待機状態だった場合、別のスレッドでもその処理を待つ状態になってしまい、結果的に処理をブロッキングしてしまうかと思います。また、各スレッドを生成する為にメモリを割り当てる必要がある為、リクエスト数毎にメモリの割当が必要になります。

ノンブロッキングIOは、基本的に処理の完了を待たず、IOが実行可能かどうかの状態を即座に返却します。実行可能であればそのまま処理を行いますが、実行できない場合はEventLoop上でそのIOの状態を監視し、実行可能状態になるまでは別の処理を行います。マルチスレッドと違い、一つのスレッドで見かけ上複数の処理を実行可能となる為、よりリソースを有効に使うことが可能です。スレッド生成によるメモリのオーバーヘッドも抑えることが可能で、スレッドの生成しすぎによるCPUのコンテキストスイッチも抑えられます。
しかし、ノンブロッキングIOを実現する為にはより複雑なプログラミングが必要となります。

SwiftNIOは、JavaにおけるNettyのSwift版とされています。NettyはJavaのノンブロッキングIOのAPIであるNIOをラップしたフレームワークであり、他のネットワークフレームワークと比べ、より応答性があり、接続エラーが少ないといった結果が出ています。
Appleは、そのNettyをベースにSwift向けの低レベルフレームワークのSwiftNIOを開発しました。

## Hello,  SwiftNIO!
それでは早速ですが、実際にSwiftNIOを使いつつ、SwiftNIOの使い方を習得しましょう！
